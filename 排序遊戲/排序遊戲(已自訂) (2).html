<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ’åºéŠæˆ²</title>
  <style>
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    /* å…¨æ–°è¯éº— CSS é¢¨æ ¼ + æ–°å¢è¨­å®šå–®å­—æ§½å¯¬åº¦é…ç½® (åƒ…ä¿®æ”¹ CSS èˆ‡éƒ¨ä»½ HTML çµæ§‹ï¼Œä¸æ”¹åŠŸèƒ½) */
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

    /* è¼‰å…¥æ³¨éŸ³å­—å‹ */
    @font-face {
      font-family: 'ã„…æ³¨éŸ³èŠ«è½ Regular';
      src: url('https://kentxchang.github.io/web/BpmfIansui-Regular_0.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    :root {
      --primary-color: #8a2be2;
      --secondary-color: #4b0082;
      --accent-color: #ff69b4;
      --background-gradient1: linear-gradient(135deg, #f0e6f6, #ffffff);
      --background-gradient2: linear-gradient(135deg, #e6f7ff, #ffffff);
      --background-gradient3: linear-gradient(135deg, #e6ffe6, #ffffff);
      --text-color: #222;
      --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    /* åŸºæœ¬é‡ç½®èˆ‡å…¨å±€æ¨£å¼ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: var(--font-main);
      background: var(--background-gradient1);
      background-size: 200% 200%;
      animation: randomBackground 15s ease infinite;
      color: var(--text-color);
      overflow-x: hidden;
    }
    @keyframes randomBackground {
      0% { background: var(--background-gradient1); }
      33% { background: var(--background-gradient2); }
      66% { background: var(--background-gradient3); }
      100% { background: var(--background-gradient1); }
    }
    
    /* ä¸»å®¹å™¨ */
    .container {
      max-width: 900px;
      margin: 2rem auto;
      padding: 1rem;
      background: rgba(255,255,255,0.95);
      border-radius: 15px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      animation: fadeInScale 1s ease-out;
    }
    @keyframes fadeInScale {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    
    /* Header èˆ‡é¡Œè™Ÿæç¤º */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 2px solid var(--secondary-color);
      margin-bottom: 1.5rem;
    }
    .question-info {
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--secondary-color);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }
    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--primary-color);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    
    /* æŒ‰éˆ•æ¨£å¼ */
    button {
      background: linear-gradient(145deg, var(--primary-color), var(--secondary-color));
      color: #fff;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    /* è¨­å®šæŒ‰éˆ• */
    #settingsBtn {
      background: transparent;
      padding: 0.5rem;
    }
    #settingsBtn svg {
      filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
    }
    
    /* Modal (åŠ å…¥æ·¡å…¥æ•ˆæœ) */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 1100;
      animation: modalFade 0.5s ease;
    }
    @keyframes modalFade {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .modal-content {
      background: #fff;
      border-radius: 10px;
      padding: 2rem;
      width: 90%;
      max-width: 600px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: slideDown 0.5s ease;
    }
    @keyframes slideDown {
      from { transform: translate(-50%, -60%); opacity: 0; }
      to { transform: translate(-50%, -50%); opacity: 1; }
    }
    
    /* è¨­å®šåœ–å±¤å…§æ‰€æœ‰è¼¸å…¥å…ƒä»¶å¯¬åº¦ 90% */
    .modal-content input,
    .modal-content textarea,
    .modal-content select {
      width: 90%;
    }
    
    /* Textarea */
    textarea {
      resize: vertical;
      font-family: var(--font-main);
      border: 2px solid var(--primary-color);
      border-radius: 8px;
      transition: border-color 0.3s;
      padding: 1rem;
      font-size: 1rem;
    }
    textarea:focus {
      outline: none;
      border-color: var(--accent-color);
    }
    
    /* è¨­å®šè¦–çª—æ–°å¢é …ç›® */
    .setting-option {
      display: flex;
      align-items: center;
      margin: 0.5rem 0;
    }
    .setting-option label {
      margin-left: 0.5rem;
      font-size: 1rem;
    }
    
    /* ä¸‹æ‹‰é¸å–®èˆ‡æ•¸å­—è¼¸å…¥ */
    .setting-option select,
    .setting-option input[type="number"] {
      padding: 0.4rem;
      border: 1px solid var(--secondary-color);
      border-radius: 5px;
      font-size: 1rem;
      margin-left: 0.5rem;
    }
    .setting-option .hint {
      margin-left: 0.5rem;
      font-size: 0.8rem;
      color: #555;
    }
    
    /* æ–°å¢å–®å­—æ§½é«˜åº¦è¨­å®š */
    .setting-option.slot-height {
      display: flex;
      align-items: center;
      margin: 0.5rem 0;
    }
    .setting-option.slot-height label {
      margin-right: 0.5rem;
      font-size: 1rem;
    }
    .setting-option.slot-height input {
      width: 60px;
      padding: 0.3rem;
      font-size: 1rem;
    }
    
    /* æ–°å¢å–®å­—æ§½å¯¬åº¦è¨­å®šï¼Œæ”¹ç‚ºä¸€æ¬„ï¼Œä¸æ›è¡Œ */
    .setting-option.slot-width {
      display: flex;
      align-items: center;
      margin: 0.5rem 0;
    }
    .setting-option.slot-width label {
      margin-right: 0.5rem;
      font-size: 1rem;
      white-space: nowrap;
    }
    .setting-option.slot-width select {
      padding: 0.4rem;
      border: 1px solid var(--secondary-color);
      border-radius: 5px;
      font-size: 1rem;
      margin-right: 0.3rem;
    }
    
    /* å°‡æ³¨éŸ³é–‹é—œã€ç­”éŒ¯é–å®šæ™‚é–“ã€å–®å­—æ§½é«˜åº¦åŠå¯¬åº¦æ’åˆ—åœ¨åŒä¸€åˆ— */
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    /* åœ–ç¤ºé–‹é—œ */
    .toggle-switch {
      display: inline-block;
      width: 50px;
      height: 26px;
      position: relative;
      cursor: pointer;
      background: #ccc;
      border-radius: 15px;
      transition: background 0.3s;
    }
    .toggle-switch::after {
      content: "";
      position: absolute;
      width: 22px;
      height: 22px;
      top: 2px;
      left: 2px;
      background: white;
      border-radius: 50%;
      transition: left 0.3s;
    }
    .toggle-switch.on {
      background: var(--primary-color);
    }
    .toggle-switch.on::after {
      left: 26px;
    }
    .toggle-label {
      margin-left: 0.5rem;
      font-size: 1rem;
    }
    
    /* è¨­å®šæŒ‰éˆ•å€ */
    .setting-actions {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin: 1rem 0;
    }
    .setting-actions button {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.3rem;
      color: #000;
      transition: transform 0.2s;
    }
    .setting-actions button:hover {
      transform: scale(1.1);
    }
    
    /* éŠæˆ²å€åŸŸ */
    #timer {
      text-align: center;
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: var(--primary-color);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    #wordContainer {
      display: flex;
      flex-direction: column;
      gap: 2rem;
      align-items: center;
      position: relative;
    }
    .word-slots {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    /* å–®å­—æ§½ï¼šå¯¬åº¦ä¾è¨­å®š (é è¨­ 150px)ï¼Œé«˜åº¦ä¾è¨­å®š (é è¨­ 150px) */
    .word-slot {
      width: 150px;
      height: 60px;
      border: 2px dashed var(--primary-color);
      border-radius: 10px;
      position: relative;
      background: rgba(255,255,255,0.8);
      transition: transform 0.3s, box-shadow 0.3s;
    }
    .word-slot:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    /* åºè™Ÿï¼šä½¿ç”¨ ::before é¡¯ç¤ºï¼Œç­”å°æ™‚éš±è— */
    .word-slot::before {
      content: attr(data-index);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: #555;
      pointer-events: none;
      z-index: 0;
    }
    .word-slot.correct::before {
      display: none;
    }
    /* æ­£ç¢ºèˆ‡éŒ¯èª¤åœ–ç¤ºå‡é€é ::after å‘ˆç¾ï¼Œä½ç½®å›ºå®šæ–¼ä¸Šæ–¹ -25px */
    .word-slot.correct::after,
    .word-slot.incorrect::after {
      display: block;
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      pointer-events: none;
      z-index: 1;
    }
    .word-slot.correct::after {
      content: 'â­•';
      color: red;
    }
    .word-slot.incorrect::after {
      content: 'âœ–ï¸';
      color: green;
    }
    
    /* å¯æ‹–æ›³å–®å­—å€ */
    #draggableWords {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
    }
    .word-item {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.8rem 1.5rem;
      font-size: 1rem;
      background: #fff;
      border-radius: 10px;
      cursor: move;
      user-select: none;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .word-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.2);
    }
    .word-item.sortable-ghost {
      opacity: 0.4;
    }
    .word-item.sortable-chosen {
      background: var(--primary-color);
      color: white;
    }
    
    /* çµæœé¡¯ç¤ºå€ (#result) - çµ•å°å®šä½ï¼Œç½®æ–¼éŠæˆ²å€å·¦å³ç½®ä¸­ã€å‘ä¸‹å°é½Š */
    #result {
      position: absolute;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      z-index: 99999;
      padding: 1rem;
      border-radius: 10px;
      background: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      animation: fadeInScale 0.5s ease-out;
    }
    
    .hidden {
      display: none;
    }
    
    /* å³ä¸‹è§’è£½ä½œè€…è³‡è¨Š */
    .credit {
      position: fixed;
      right: 1rem;
      bottom: 1rem;
      font-size: 0.9rem;
      z-index: 1500;
    }
    .credit a {
      color: var(--primary-color);
      text-decoration: none;
    }
    .credit a:hover {
      text-decoration: underline;
    }
    
    /* å€’æ•¸æ•¸å­— (åƒ…åœ¨é–å®šæ™‚é–“é0æ™‚å‹•æ…‹åŠ å…¥) */
    .lock-countdown {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      color: red;
      pointer-events: none;
    }
    
    /* éš±è—æª”æ¡ˆè¼¸å…¥ */
    #importFile {
      display: none;
    }
    
    /* RWD èª¿æ•´ */
    @media (max-width: 600px) {
      h1 {
        font-size: 1.8rem;
      }
      button {
        font-size: 0.9rem;
        padding: 0.6rem 1rem;
      }
      .word-slot {
        width: 120px;
        height: 120px;
      }
      .word-item {
        font-size: 0.9rem;
        padding: 0.6rem 1rem;
      }
      #timer {
        font-size: 1.3rem;
      }
    }
    
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    /* å…¨æ–° CSS çµæŸ */
    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <!-- é¡Œè™Ÿæç¤º -->
      <div class="question-info" id="questionInfo">ç¬¬ 0 é¡Œï¼Œå…± 0 é¡Œ</div>
      <h1>æ’å‡ºæ­£ç¢ºé †åºå§!</h1>
      <button id="settingsBtn">
        <svg width="24" height="24" viewBox="0 0 24 24">
          <path fill="currentColor" d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
        </svg>
      </button>
    </div>
    
    <!-- è¨­å®šé€²å…¥å¯†ç¢¼æ¨¡çµ„ (åˆ†åˆ—å‘ˆç¾) -->
    <div id="passwordModal" class="modal">
      <div class="modal-content">
        <h2>è«‹è¼¸å…¥å¯†ç¢¼</h2>
        <input type="password" id="passwordInput" placeholder="å¯†ç¢¼">
        <br>
        <button id="passwordSubmit">ç¢ºèª</button>
      </div>
    </div>
    
    <!-- è¨­å®šè¦–çª— -->
    <div id="settingsModal" class="modal">
      <div class="modal-content">
        <h2>è¨­å®š</h2>
        <textarea id="wordSets" rows="10" placeholder="è«‹è¼¸å…¥å–®å­—çµ„ï¼ˆæ¯çµ„ä¸€è¡Œï¼Œå–®å­—ä»¥ç©ºæ ¼åˆ†éš”ï¼‰ï¼š
ç¯„ä¾‹ï¼š
B o o k
é˜¿å‰› è€å¸« è¶…ç´š å¸¥"></textarea>
        <!-- å°‡æ³¨éŸ³é–‹é—œã€ç­”éŒ¯é–å®šæ™‚é–“ã€å–®å­—æ§½é«˜åº¦åŠå¯¬åº¦æ’åˆ—åœ¨åŒä¸€åˆ— -->
        <div class="settings-row">
          <div class="setting-option">
            <div class="toggle-switch" id="bpmfToggle"></div>
            <span class="toggle-label" id="bpmfLabel">æ³¨éŸ³ï¼šOFF</span>
          </div>
          <div class="setting-option lock-time">
            <label for="lockTime">ç­”éŒ¯é–å®šæ™‚é–“:</label>
            <select id="lockTime">
              <option value="0">0ç§’</option>
              <option value="5">5ç§’</option>
              <option value="10">10ç§’</option>
              <option value="15">15ç§’</option>
            </select>
          </div>
          <div class="setting-option slot-height">
            <label for="slotHeight">å–®å­—æ§½é«˜åº¦:</label>
            <input type="number" id="slotHeight" value="60" min="50">
            <span class="hint">(å¦‚æœé¡Œç›®å­—å¤šæ™‚ï¼Œå¯åŠ å¤§æ•¸å­—)</span>
          </div>
          <div class="setting-option slot-width">
            <label for="slotWidth">å–®å­—æ§½å¯¬åº¦:</label>
            <select id="slotWidth">
              <option value="150" selected>150</option>
              <option value="60">60 (è‹±æ–‡å­—æ¯æ™‚ä½¿ç”¨)</option>
            </select>
          </div>
        </div>
        <!-- åŒ¯å‡ºï¼åŒ¯å…¥åŠä¸‹è¼‰ HTML æŒ‰éˆ• -->
        <div class="setting-actions">
          <button id="exportConfig">ğŸ“¤ åŒ¯å‡º</button>
          <button id="importConfig">ğŸ“¥ åŒ¯å…¥</button>
          <button id="downloadHtml">ğŸ’¾ ä¸‹è¼‰ HTML</button>
          <input type="file" id="importFile" accept="application/json">
        </div>
        <button id="startGame">é–‹å§‹éŠæˆ²</button>
      </div>
    </div>
    
    <!-- alli è¼¸å…¥ modal -->
    <div id="alliModal" class="modal">
      <div class="modal-content">
        <h2>è¼¸å…¥ JSON è¨­å®š</h2>
        <textarea id="alliInput" rows="10" placeholder="è«‹è²¼ä¸Š JSON å…§å®¹">{
  "wordSets": "f r i e n d\nb o o k",
  "useBpmf": true,
  "lockTime": "0",
  "slotHeight": "60",
  "slotWidth": "60"
}</textarea>
        <button id="alliImport">å°å…¥</button>
      </div>
    </div>
    
    <div id="gameArea">
      <div id="timer">æ™‚é–“ï¼š0:00</div>
      <!-- wordContainer å…§ä¾åºåŠ å…¥å–®å­—æ§½å€èˆ‡å¯æ‹–æ›³å–®å­—å€ -->
      <div id="wordContainer"></div>
      <!-- çµæœé¡¯ç¤ºå€ (#result) çµ•å°å®šä½æ–¼éŠæˆ²å€å·¦å³ç½®ä¸­ï¼Œå‘ä¸‹å°é½Š -->
      <div id="result" class="hidden">
        <p>å®Œæˆæ™‚é–“ï¼š<span id="completionTime"></span></p>
        <button id="nextSet" class="hidden">ä¸‹ä¸€çµ„</button>
        <button id="restart" class="hidden">é‡æ–°é–‹å§‹éŠæˆ²</button>
      </div>
    </div>
  </div>
  
  <!-- å³ä¸‹è§’è£½ä½œè€…è³‡è¨Š -->
  <div id="credit" class="credit">
    Made by <a href="https://kentxchang.blogspot.tw" target="_blank">é˜¿å‰›è€å¸«</a>
  </div>
  
  <!-- è¼‰å…¥ SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
  
  <script>
    class WordSortingGame {
      constructor() {
        this.wordSets = [];
        this.currentSetIndex = 0;
        this.startTime = 0;
        this.timerInterval = null;
        this.originalOrder = [];
        this.pastelColors = [
          '#FFE5E5', '#E5FFE5', '#E5E5FF', '#FFE5FF', '#FFFFE5',
          '#E5FFFF', '#F5E6E8', '#E6F5E8', '#E6E8F5', '#F5E6F5'
        ];
        this.useBpmf = false;
        this.initializeElements();
        this.setupEventListeners();
        if (this.alliInput.value.trim() !== "") {
          this.alliImport();
        }
      }
    
      initializeElements() {
        this.settingsBtn = document.getElementById('settingsBtn');
        this.passwordModal = document.getElementById('passwordModal');
        this.passwordInput = document.getElementById('passwordInput');
        this.passwordSubmit = document.getElementById('passwordSubmit');
        this.settingsModal = document.getElementById('settingsModal');
        this.wordSetsInput = document.getElementById('wordSets');
        this.bpmfToggle = document.getElementById('bpmfToggle');
        this.bpmfLabel = document.getElementById('bpmfLabel');
        this.lockTimeSelect = document.getElementById('lockTime');
        this.exportConfigBtn = document.getElementById('exportConfig');
        this.importConfigBtn = document.getElementById('importConfig');
        this.downloadHtmlBtnSettings = document.getElementById('downloadHtml');
        this.importFileInput = document.getElementById('importFile');
        this.startGameBtn = document.getElementById('startGame');
        this.alliModal = document.getElementById('alliModal');
        this.alliInput = document.getElementById('alliInput');
        this.alliImportBtn = document.getElementById('alliImport');
        this.gameArea = document.getElementById('gameArea');
        this.wordContainer = document.getElementById('wordContainer');
        this.timerElement = document.getElementById('timer');
        this.resultElement = document.getElementById('result');
        this.completionTimeElement = document.getElementById('completionTime');
        this.nextSetBtn = document.getElementById('nextSet');
        this.restartBtn = document.getElementById('restart');
        this.questionInfo = document.getElementById('questionInfo');
      }
    
      setupEventListeners() {
        this.settingsBtn.addEventListener('click', () => {
          this.passwordModal.style.display = 'block';
        });
    
        this.passwordInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            this.passwordSubmit.click();
          }
        });
    
        this.passwordSubmit.addEventListener('click', () => {
          if (this.passwordInput.value === 'tpet') {
            this.passwordModal.style.display = 'none';
            this.settingsModal.style.display = 'block';
            this.passwordInput.value = '';
          } else {
            alert('å¯†ç¢¼éŒ¯èª¤ï¼');
          }
        });
    
        this.startGameBtn.addEventListener('click', () => this.startGame());
        this.nextSetBtn.addEventListener('click', () => this.loadNextSet());
        this.restartBtn.addEventListener('click', () => this.restartGame());
    
        this.exportConfigBtn.addEventListener('click', () => {
          const configJson = this.exportConfig();
          const blob = new Blob([configJson], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'config.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
    
        this.importConfigBtn.addEventListener('click', () => this.importFileInput.click());
        this.importFileInput.addEventListener('change', (e) => this.importConfig(e));
    
        this.downloadHtmlBtnSettings.addEventListener('click', () => this.prepareDownloadHtml());
    
        this.alliImportBtn.addEventListener('click', () => this.alliImport());
    
        window.addEventListener('click', (e) => {
          if (e.target === this.settingsModal) {
            this.settingsModal.style.display = 'none';
          }
          if (e.target === this.alliModal) {
            this.alliModal.style.display = 'none';
          }
          if (e.target === this.passwordModal) {
            this.passwordModal.style.display = 'none';
          }
        });
    
        this.bpmfToggle.addEventListener('click', () => {
          this.useBpmf = !this.useBpmf;
          if (this.useBpmf) {
            this.bpmfToggle.classList.add('on');
            this.bpmfLabel.textContent = 'æ³¨éŸ³ï¼šON';
          } else {
            this.bpmfToggle.classList.remove('on');
            this.bpmfLabel.textContent = 'æ³¨éŸ³ï¼šOFF';
          }
          this.updateFont();
        });
    
        document.addEventListener('keydown', (e) => {
          if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'i') {
            this.alliModal.style.display = 'block';
          }
        });
      }
    
      updateFont() {
        if (this.useBpmf) {
          document.body.style.fontFamily = "'ã„…æ³¨éŸ³èŠ«è½ Regular', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
        } else {
          document.body.style.fontFamily = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
        }
      }
    
      startGame() {
        const input = this.wordSetsInput.value.trim();
        if (!input) return;
        this.wordSets = this.wordSetsInput.value.split('\n').map(line => line.trim());
        this.currentSetIndex = 0;
        this.useBpmf = this.bpmfToggle.classList.contains('on');
        this.updateFont();
        this.settingsModal.style.display = 'none';
        this.loadCurrentSet();
      }
    
      loadCurrentSet() {
        if (this.currentSetIndex >= this.wordSets.length) return;
        const words = this.wordSets[this.currentSetIndex].split(' ');
        this.originalOrder = [...words];
        const shuffledWords = this.shuffleArray([...words]);
        this.questionInfo.textContent = `ç¬¬ ${this.currentSetIndex + 1} é¡Œï¼Œå…± ${this.wordSets.length} é¡Œ`;
    
        const slotsContainer = document.createElement('div');
        slotsContainer.className = 'word-slots';
        words.forEach((word, index) => {
          const slot = document.createElement('div');
          slot.className = 'word-slot';
          slot.setAttribute('data-index', index + 1);
          const height = document.getElementById('slotHeight').value;
          const width = document.getElementById('slotWidth').value;
          slot.style.height = height + 'px';
          slot.style.width = width + 'px';
          slotsContainer.appendChild(slot);
        });
    
        const wordsContainer = document.createElement('div');
        wordsContainer.id = 'draggableWords';
        wordsContainer.style.display = 'flex';
        wordsContainer.style.gap = '1rem';
        wordsContainer.style.justifyContent = 'center';
        wordsContainer.style.flexWrap = 'wrap';
    
        shuffledWords.forEach(word => {
          const wordElement = document.createElement('div');
          wordElement.className = 'word-item';
          wordElement.textContent = word;
          wordElement.style.backgroundColor = this.getRandomPastelColor();
          wordsContainer.appendChild(wordElement);
        });
    
        this.wordContainer.innerHTML = '';
        this.wordContainer.appendChild(slotsContainer);
        this.wordContainer.appendChild(wordsContainer);
    
        this.setupSortable();
        this.startTimer();
        this.resultElement.classList.add('hidden');
        this.nextSetBtn.classList.add('hidden');
        this.restartBtn.classList.add('hidden');
      }
    
      setupSortable() {
        const slots = document.querySelectorAll('.word-slot');
        const draggableWords = document.getElementById('draggableWords');
        if (this.sortable) { this.sortable.destroy(); }
        this.sortable = new Sortable(draggableWords, {
          animation: 150,
          group: 'shared',
        });
        slots.forEach((slot, index) => {
          new Sortable(slot, {
            group: 'shared',
            animation: 150,
            onAdd: (evt) => {
              if (slot.classList.contains('locked')) {
                draggableWords.appendChild(evt.item);
                return;
              }
              const droppedText = evt.item.textContent;
              const expectedText = this.originalOrder[index];
              let lockTime = parseInt(this.lockTimeSelect.value);
              if (lockTime === 0) { lockTime = 2; }
              if (droppedText !== expectedText) {
                draggableWords.appendChild(evt.item);
                if (!slot.classList.contains('locked')) {
                  this.lockSlot(slot, lockTime);
                }
                return;
              }
              if (slot.children.length > 1) {
                draggableWords.appendChild(slot.children[0]);
              }
              slot.classList.add('correct');
              this.checkAllSlots();
            },
            onRemove: (evt) => {
              if (!slot.classList.contains('locked')) {
                slot.classList.remove('correct', 'incorrect');
              }
            }
          });
        });
      }
    
      checkAllSlots() {
        const slots = document.querySelectorAll('.word-slot');
        const allCorrect = Array.from(slots).every((slot, index) => {
          if (slot.children.length === 0) return false;
          return slot.children[0].textContent === this.originalOrder[index];
        });
        if (allCorrect) {
          this.handleSuccess();
        }
      }
    
      lockSlot(slot, seconds) {
        slot.classList.add('locked');
        slot.classList.add('incorrect');
        if (parseInt(this.lockTimeSelect.value) === 0) {
          setTimeout(() => {
            slot.classList.remove('incorrect');
            slot.classList.remove('locked');
          }, 2000);
        } else {
          const countdownElem = document.createElement('div');
          countdownElem.className = 'lock-countdown';
          countdownElem.textContent = seconds + 's';
          slot.appendChild(countdownElem);
          const intervalId = setInterval(() => {
            seconds--;
            if (seconds <= 0) {
              clearInterval(intervalId);
              slot.classList.remove('incorrect');
              slot.classList.remove('locked');
              countdownElem.remove();
            } else {
              countdownElem.textContent = seconds + 's';
            }
          }, 1000);
        }
      }
    
      handleSuccess() {
        clearInterval(this.timerInterval);
        const timeTaken = this.formatTime((Date.now() - this.startTime) / 1000);
        this.resultElement.classList.remove('hidden');
        this.completionTimeElement.textContent = timeTaken;
        if (this.currentSetIndex < this.wordSets.length - 1) {
          this.nextSetBtn.classList.remove('hidden');
        } else {
          this.restartBtn.classList.remove('hidden');
        }
      }
    
      loadNextSet() {
        this.currentSetIndex++;
        this.loadCurrentSet();
      }
    
      restartGame() {
        this.currentSetIndex = 0;
        this.loadCurrentSet();
      }
    
      startTimer() {
        clearInterval(this.timerInterval);
        this.startTime = Date.now();
        this.updateTimer();
        this.timerInterval = setInterval(() => this.updateTimer(), 1000);
      }
    
      updateTimer() {
        const seconds = Math.floor((Date.now() - this.startTime) / 1000);
        this.timerElement.textContent = `æ™‚é–“ï¼š${this.formatTime(seconds)}`;
      }
    
      formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
      }
    
      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
    
      getRandomPastelColor() {
        return this.pastelColors[Math.floor(Math.random() * this.pastelColors.length)];
      }
    
      exportConfig() {
        const config = {
          wordSets: this.wordSetsInput.value,
          useBpmf: this.bpmfToggle.classList.contains('on'),
          lockTime: this.lockTimeSelect.value,
          slotHeight: document.getElementById('slotHeight').value,
          slotWidth: document.getElementById('slotWidth').value
        };
        return JSON.stringify(config, null, 2);
      }
    
      importConfig(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const config = JSON.parse(e.target.result);
            if (config.wordSets !== undefined) {
              this.wordSetsInput.value = config.wordSets;
            }
            if (config.useBpmf !== undefined) {
              if (config.useBpmf) {
                this.bpmfToggle.classList.add('on');
                this.bpmfLabel.textContent = 'æ³¨éŸ³ï¼šON';
              } else {
                this.bpmfToggle.classList.remove('on');
                this.bpmfLabel.textContent = 'æ³¨éŸ³ï¼šOFF';
              }
              this.useBpmf = config.useBpmf;
              this.updateFont();
            }
            if (config.lockTime !== undefined) {
              this.lockTimeSelect.value = config.lockTime;
            }
            if (config.slotHeight !== undefined) {
              document.getElementById('slotHeight').value = config.slotHeight;
            }
            if (config.slotWidth !== undefined) {
              document.getElementById('slotWidth').value = config.slotWidth;
            }
          } catch (err) {
            alert('åŒ¯å…¥è¨­å®šå¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼ã€‚');
          }
        };
        reader.readAsText(file);
      }
    
      alliImport() {
        const jsonText = this.alliInput.value.trim();
        if (!jsonText) return;
        try {
          const config = JSON.parse(jsonText);
          if (config.wordSets !== undefined) {
            this.wordSetsInput.value = config.wordSets;
          }
          if (config.useBpmf !== undefined) {
            if (config.useBpmf) {
              this.bpmfToggle.classList.add('on');
              this.bpmfLabel.textContent = 'æ³¨éŸ³ï¼šON';
            } else {
              this.bpmfToggle.classList.remove('on');
              this.bpmfLabel.textContent = 'æ³¨éŸ³ï¼šOFF';
            }
            this.useBpmf = config.useBpmf;
            this.updateFont();
          }
          if (config.lockTime !== undefined) {
            this.lockTimeSelect.value = config.lockTime;
          }
          if (config.slotHeight !== undefined) {
            document.getElementById('slotHeight').value = config.slotHeight;
          }
          if (config.slotWidth !== undefined) {
            document.getElementById('slotWidth').value = config.slotWidth;
          }
          this.alliModal.style.display = 'none';
          this.startGame();
        } catch (err) {
          alert('åŒ¯å…¥è¨­å®šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ JSON æ ¼å¼ã€‚');
        }
      }
    
      prepareDownloadHtml() {
        const url = 'https://filedn.com/laMtL9jmKf7JrDEQG0A6OPy/html/%E6%8E%92%E5%BA%8F%E9%81%8A%E6%88%B2/%E6%8E%92%E5%BA%8F%E9%81%8A%E6%88%B2.html';
        fetch(url)
          .then(response => response.text())
          .then(htmlText => {
            const configJson = this.exportConfig();
            const newHtml = htmlText.replace(/(<textarea\s+id="alliInput"[^>]*>)[\s\S]*?(<\/textarea>)/, `$1${configJson}$2`);
            const blob = new Blob([newHtml], { type: 'text/html' });
            const downloadUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = 'æ’åºéŠæˆ²(å·²è‡ªè¨‚).html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(downloadUrl);
          })
          .catch(err => {
            alert('è¼‰å…¥ HTML å¤±æ•—ï¼š' + err);
          });
      }
    }
    
    document.addEventListener('DOMContentLoaded', () => {
      new WordSortingGame();
    });
  </script>
</body>
</html>
