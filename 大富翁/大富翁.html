<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>台灣大富翁 v2.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            touch-action: manipulation;
        }
        .board {
            display: grid;
            grid-template-columns: 100px repeat(9, 1fr) 100px;
            grid-template-rows: 100px repeat(9, 1fr) 100px;
            gap: 2px;
            width: 95vw;
            max-width: 900px;
            margin: auto;
            border: 2px solid #1a1a1a;
            background-color: #f7f3e8;
            position: relative; /* Ensure the board is positioned for absolute pawns */
        }
        .space {
            position: relative; border: 1px solid #ccc; display: flex; flex-direction: column;
            justify-content: space-between; align-items: center; padding: 2px;
            font-size: 0.7rem; text-align: center; overflow: hidden; background-color: white;
        }
        .space .name { padding: 2px; line-height: 1.2; }
        .space .price { font-weight: 500; }
        .color-bar { width: 100%; height: 15%; flex-shrink: 0; }
        .corner { font-size: 1rem; font-weight: bold; display: flex; align-items: center; justify-content: center; }
        .space-0 { grid-column: 11 / 12; grid-row: 11 / 12; } .space-1 { grid-column: 10 / 11; grid-row: 11 / 12; }
        .space-2 { grid-column: 9 / 10; grid-row: 11 / 12; } .space-3 { grid-column: 8 / 9; grid-row: 11 / 12; }
        .space-4 { grid-column: 7 / 8; grid-row: 11 / 12; } .space-5 { grid-column: 6 / 7; grid-row: 11 / 12; }
        .space-6 { grid-column: 5 / 6; grid-row: 11 / 12; } .space-7 { grid-column: 4 / 5; grid-row: 11 / 12; }
        .space-8 { grid-column: 3 / 4; grid-row: 11 / 12; } .space-9 { grid-column: 2 / 3; grid-row: 11 / 12; }
        .space-10 { grid-column: 1 / 2; grid-row: 11 / 12; } .space-11 { grid-column: 1 / 2; grid-row: 10 / 11; }
        .space-12 { grid-column: 1 / 2; grid-row: 9 / 10; } .space-13 { grid-column: 1 / 2; grid-row: 8 / 9; }
        .space-14 { grid-column: 1 / 2; grid-row: 7 / 8; } .space-15 { grid-column: 1 / 2; grid-row: 6 / 7; }
        .space-16 { grid-column: 1 / 2; grid-row: 5 / 6; } .space-17 { grid-column: 1 / 2; grid-row: 4 / 5; }
        .space-18 { grid-column: 1 / 2; grid-row: 3 / 4; } .space-19 { grid-column: 1 / 2; grid-row: 2 / 3; }
        .space-20 { grid-column: 1 / 2; grid-row: 1 / 2; } .space-21 { grid-column: 2 / 3; grid-row: 1 / 2; }
        .space-22 { grid-column: 3 / 4; grid-row: 1 / 2; } .space-23 { grid-column: 4 / 5; grid-row: 1 / 2; }
        .space-24 { grid-column: 5 / 6; grid-row: 1 / 2; } .space-25 { grid-column: 6 / 7; grid-row: 1 / 2; }
        .space-26 { grid-column: 7 / 8; grid-row: 1 / 2; } .space-27 { grid-column: 8 / 9; grid-row: 1 / 2; }
        .space-28 { grid-column: 9 / 10; grid-row: 1 / 2; } .space-29 { grid-column: 10 / 11; grid-row: 1 / 2; }
        .space-30 { grid-column: 11 / 12; grid-row: 1 / 2; } .space-31 { grid-column: 11 / 12; grid-row: 2 / 3; }
        .space-32 { grid-column: 11 / 12; grid-row: 3 / 4; } .space-33 { grid-column: 11 / 12; grid-row: 4 / 5; }
        .space-34 { grid-column: 11 / 12; grid-row: 5 / 6; } .space-35 { grid-column: 11 / 12; grid-row: 6 / 7; }
        .space-36 { grid-column: 11 / 12; grid-row: 7 / 8; } .space-37 { grid-column: 11 / 12; grid-row: 8 / 9; }
        .space-38 { grid-column: 11 / 12; grid-row: 9 / 10; } .space-39 { grid-column: 11 / 12; grid-row: 10 / 11; }
        .center-area {
            grid-column: 2 / 11; grid-row: 2 / 11; display: flex; flex-direction: column;
            justify-content: center; align-items: center; padding: 20px;
        }
        .player-pawn {
            position: absolute;
            width: 50px;   /* Doubled from 25px */
            height: 50px;  /* Doubled from 25px */
            transition: all 0.5s ease-in-out;
            z-index: 10; /* Ensures pawns are above other board elements */
            font-size: 40px; /* Doubled from 20px */
            text-align: center;
            line-height: 50px; /* Doubled from 25px */
            text-shadow: 0 0 3px white, 0 0 5px white;
        }
        .owner-indicator { position: absolute; bottom: 0; left: 0; width: 100%; height: 5px; }
        @media (max-width: 768px) {
            .board { grid-template-columns: 60px repeat(9, 1fr) 60px; grid-template-rows: 60px repeat(9, 1fr) 60px; gap: 1px; }
            .space { font-size: 0.5rem; } .corner { font-size: 0.7rem; }
            .player-pawn { width: 40px; height: 40px; font-size: 32px; line-height: 40px; } /* Adjusted for mobile */
            .center-area { padding: 10px; } .player-info { margin-bottom: 5px; }
        }
        .made-by {
            position: fixed; bottom: 10px; right: 10px; padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.8); border-radius: 8px;
            font-size: 0.8rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .made-by a { color: #3b82f6; text-decoration: none; }
        .made-by a:hover { text-decoration: underline; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Setup Screen -->
    <div id="setup-screen" class="w-full max-w-lg p-8 bg-white rounded-lg shadow-xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">台灣大富翁 - 遊戲設定</h1>
        <div class="mb-4">
            <label for="player-count" class="block text-gray-700 text-sm font-bold mb-2">玩家人數:</label>
            <select id="player-count" class="shadow border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <option value="2" selected>2 人</option>
                <option value="3">3 人</option>
                <option value="4">4 人</option>
            </select>
        </div>
        <div id="player-details" class="mb-4"></div>
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold mb-2">初始資金:</label>
            <div class="flex items-center space-x-2">
                <select id="initial-money-select" class="shadow border rounded w-full py-2 px-3 text-gray-700">
                    <option value="15000">$15,000 (預設)</option>
                    <option value="10000">$10,000</option>
                    <option value="5000">$5,000</option>
                </select>
                <input type="number" id="initial-money-custom" class="shadow border rounded w-full py-2 px-3 text-gray-700 hidden" placeholder="輸入金額" value="15000">
            </div>
        </div>
        <div class="mb-6">
            <label class="block text-gray-700 text-sm font-bold mb-2">遊戲時間:</label>
            <div class="flex items-center space-x-2">
                <select id="game-time-select" class="shadow border rounded w-full py-2 px-3 text-gray-700">
                    <option value="0">不計時</option>
                    <option value="10">10 分鐘</option>
                    <option value="20">20 分鐘</option>
                    <option value="custom">自訂 (分鐘)</option>
                </select>
                <input type="number" id="game-time-custom" class="shadow border rounded w-full py-2 px-3 text-gray-700 hidden" placeholder="輸入分鐘" value="30">
            </div>
        </div>
        <button id="start-game-btn" class="w-full bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition duration-300">
            開始新遊戲
        </button>
    </div>

    <!-- Game Screen (Initially Hidden) -->
    <div id="game-screen" class="hidden w-full">
        <h1 class="text-2xl md:text-4xl font-bold text-gray-800 mb-2 text-center">台灣大富翁</h1>
        <div id="timer-display" class="text-center text-xl font-bold text-red-600 mb-2"></div>

        <div class="flex flex-col md:flex-row w-full max-w-7xl mx-auto">
            <div class="relative flex-grow">
                <div id="game-board" class="board">
                </div>
            </div>
            <div class="w-full md:w-64 lg:w-80 mt-4 md:mt-0 md:ml-4 flex-shrink-0">
                <div id="player-info-container" class="bg-white p-4 rounded-lg shadow-md"></div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div id="buy-property-modal" class="bg-white rounded-lg shadow-2xl p-6 w-11/12 max-w-sm text-center hidden">
            <h3 id="buy-property-name" class="text-2xl font-bold mb-2"></h3>
            <p id="buy-property-price" class="text-xl text-gray-700 mb-4"></p>
            <p class="text-gray-500 mb-6">您想要購買這塊土地嗎？</p>
            <div class="flex justify-center space-x-4">
                <button id="buy-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300">購買</button>
                <button id="skip-buy-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300">放棄</button>
            </div>
        </div>
        <div id="card-modal" class="bg-white rounded-lg shadow-2xl p-6 w-11/12 max-w-sm text-center hidden">
            <h3 id="card-title" class="text-2xl font-bold mb-2"></h3>
            <p id="card-text" class="text-lg text-gray-700 mb-6"></p>
            <button id="card-ok-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300">確定</button>
        </div>
        <div id="message-modal" class="bg-white rounded-lg shadow-2xl p-6 w-11/12 max-w-sm text-center hidden">
            <p id="message-text" class="text-lg text-gray-700 mb-6"></p>
            <button id="message-ok-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300">了解</button>
        </div>
        <div id="winner-modal" class="bg-white rounded-lg shadow-2xl p-8 w-11/12 max-w-md text-center hidden">
            <h3 id="winner-title" class="text-3xl font-bold mb-4 text-yellow-500">遊戲結束！</h3>
            <p id="winner-text" class="text-xl text-gray-800 mb-2"></p>
            <p id="winner-details" class="text-md text-gray-600 mb-6"></p>
            <button id="play-again-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 text-lg">重新開始一局</button>
        </div>
        <div id="confirm-modal" class="bg-white rounded-lg shadow-2xl p-6 w-11/12 max-w-sm text-center hidden">
            <p id="confirm-text" class="text-lg text-gray-700 mb-6"></p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-yes-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg">確定</button>
                <button id="confirm-no-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg">取消</button>
            </div>
        </div>
    </div>

    <div class="made-by">Made by <a href="https://kentxchang.blogspot.tw" target="_blank">阿剛老師</a></div>

    <script>
        // --- DATA ---
        const initialBoardSpacesData = [
            { name: '起點', type: 'go' }, { name: '墾丁大街', type: 'property', price: 600, rent: 20, group: '#8B4513' },
            { name: '命運', type: 'destiny' }, { name: '鵝鑾鼻公園', type: 'property', price: 600, rent: 40, group: '#8B4513' },
            { name: '所得稅', type: 'tax', amount: 2000 }, { name: '高鐵左營站', type: 'station', price: 2000, rent: 250 },
            { name: '安平古堡', type: 'property', price: 1000, rent: 60, group: '#ADD8E6' }, { name: '機會', type: 'chance' },
            { name: '赤崁樓', type: 'property', price: 1000, rent: 60, group: '#ADD8E6' }, { name: '七股鹽山', type: 'property', price: 1200, rent: 80, group: '#ADD8E6' },
            { name: '監獄', type: 'jail' }, { name: '日月潭', type: 'property', price: 1400, rent: 100, group: '#FFC0CB' },
            { name: '台積電', type: 'utility', price: 1500 }, { name: '清境農場', type: 'property', price: 1400, rent: 100, group: '#FFC0CB' },
            { name: '逢甲夜市', type: 'property', price: 1600, rent: 120, group: '#FFC0CB' }, { name: '高鐵台中站', type: 'station', price: 2000, rent: 250 },
            { name: '大溪老街', type: 'property', price: 1800, rent: 140, group: '#FFA500' }, { name: '命運', type: 'destiny' },
            { name: '石門水庫', type: 'property', price: 1800, rent: 140, group: '#FFA500' }, { name: '小人國', type: 'property', price: 2000, rent: 160, group: '#FFA500' },
            { name: '免費停車', type: 'parking' }, { name: '故宮博物院', type: 'property', price: 2200, rent: 180, group: '#FF0000' },
            { name: '機會', type: 'chance' }, { name: '中正紀念堂', type: 'property', price: 2200, rent: 180, group: '#FF0000' },
            { name: '士林夜市', type: 'property', price: 2400, rent: 200, group: '#FF0000' }, { name: '高鐵台北站', type: 'station', price: 2000, rent: 250 },
            { name: '淡水老街', type: 'property', price: 2600, rent: 220, group: '#FFFF00' }, { name: '九份', type: 'property', price: 2600, rent: 220, group: '#FFFF00' },
            { name: '長榮海運', type: 'utility', price: 1500 }, { name: '野柳女王頭', type: 'property', price: 2800, rent: 240, group: '#FFFF00' },
            { name: '前往監獄', type: 'goToJail' }, { name: '太魯閣', type: 'property', price: 3000, rent: 260, group: '#008000' },
            { name: '清水斷崖', type: 'property', price: 3000, rent: 260, group: '#008000' }, { name: '命運', type: 'destiny' },
            { name: '七星潭', type: 'property', price: 3200, rent: 280, group: '#008000' }, { name: '高鐵花蓮站', type: 'station', price: 2000, rent: 250 },
            { name: '機會', type: 'chance' }, { name: '陽明山', type: 'property', price: 3500, rent: 350, group: '#0000FF' },
            { name: '奢侈稅', type: 'tax', amount: 1000 }, { name: '台北101', type: 'property', price: 4000, rent: 500, group: '#0000FF' },
        ];
        const chanceCards = [
            { text: "中統一發票，獲得 $2000。", action: 'money', amount: 2000 }, { text: "領到夜市消費券，獲得 $1000。", action: 'money', amount: 1000 },
            { text: "繳交健保費 $500。", action: 'money', amount: -500 }, { text: "前進到「起點」，領取薪水。", action: 'move', position: 0 },
            { text: "免費出獄卡。可以保留或出售。", action: 'getOutOfJail' }, { text: "前進到「台北101」。", action: 'move', position: 39 },
            { text: "銀行分紅，您獲得 $1500。", action: 'money', amount: 1500 }, { text: "前進三步。", action: 'moveRelative', amount: 3 },
        ];
        const destinyCards = [
            { text: "機車超速罰單 $300。", action: 'money', amount: -300 }, { text: "颱風來襲，所有房屋修繕費 $500。", action: 'money', amount: -500 },
            { text: "直接進入監獄，不得通過起點。", action: 'goToJail' }, { text: "別人請客，獲得 $200。", action: 'money', amount: 200 },
            { text: "遺產繼承，獲得 $1000。", action: 'money', amount: 1000 }, { text: "繳交所得稅 $1500。", action: 'money', amount: -1500 },
            { text: "生日禮金，獲得 $500。", action: 'money', amount: 500 },
        ];
        
        let gameState = {};
        let gameTimerInterval = null;

        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const playerCountSelect = document.getElementById('player-count');
        const playerDetailsContainer = document.getElementById('player-details');
        const initialMoneySelect = document.getElementById('initial-money-select');
        const initialMoneyCustom = document.getElementById('initial-money-custom');
        const gameTimeSelect = document.getElementById('game-time-select');
        const gameTimeCustom = document.getElementById('game-time-custom');
        const startGameBtn = document.getElementById('start-game-btn');
        const timerDisplay = document.getElementById('timer-display');
        const boardElement = document.getElementById('game-board');
        const playerInfoContainer = document.getElementById('player-info-container');
        const modalContainer = document.getElementById('modal-container');
        const winnerModal = document.getElementById('winner-modal');
        const confirmModal = document.getElementById('confirm-modal');
        const buyPropertyModal = document.getElementById('buy-property-modal');
        const cardModal = document.getElementById('card-modal');
        const messageModal = document.getElementById('message-modal');
        const playerColors = ['#ef4444', '#3b82f6', '#22c55e', '#f97316'];
        // Added more emojis for player selection
        const availableEmojis = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵', '🐔', '🐧', '🐦', '🐥', '🐺', '🐗', '🐴', '🦄', '🐝', '🦋', '🐌', '🐞', '🐠', '🐙'];
        
        const boardDataWithOwners = initialBoardSpacesData.map(space => {
            if (['property', 'station', 'utility'].includes(space.type)) {
                return { ...space, ownerId: null };
            }
            return space;
        });

        // Function to update the player details section on the setup screen
        function updatePlayerDetailsView() {
            const count = parseInt(playerCountSelect.value);
            playerDetailsContainer.innerHTML = '';
            let usedEmojis = [];
            for (let i = 0; i < count; i++) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'grid grid-cols-2 gap-4 items-center mb-2';
                
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.id = `player-name-${i}`;
                nameInput.className = 'shadow border rounded w-full py-2 px-3 text-gray-700';
                nameInput.placeholder = `玩家 ${i + 1} 名稱`;
                nameInput.value = `玩家 ${i + 1}`;
                
                const emojiSelect = document.createElement('select');
                emojiSelect.id = `player-emoji-${i}`;
                emojiSelect.className = 'shadow border rounded w-full py-2 px-3 text-gray-700';
                
                // Filter available emojis to ensure uniqueness
                const availableForThisPlayer = availableEmojis.filter(e => !usedEmojis.includes(e));
                availableForThisPlayer.forEach((emoji, index) => {
                    const option = document.createElement('option');
                    option.value = emoji;
                    option.textContent = emoji;
                    if (index === 0) { // Automatically select the first available unique emoji
                        option.selected = true;
                        usedEmojis.push(emoji); // Mark it as used
                    }
                    emojiSelect.appendChild(option);
                });

                // Event listener to prevent duplicate emoji selection
                emojiSelect.addEventListener('change', (e) => {
                    const allSelects = Array.from(playerDetailsContainer.querySelectorAll('select'));
                    const selectedValues = allSelects.map(s => s.value);
                    const duplicates = selectedValues.filter((item, index) => selectedValues.indexOf(item) !== index);

                    if(duplicates.length > 0) {
                        // Use showMessage instead of alert for better UX
                        showMessage("每位玩家請選擇不同的棋子！", () => {
                            // Find a new unique emoji for the current select if a duplicate was chosen
                            const currentSelect = e.target;
                            const otherValues = allSelects.filter(s => s !== currentSelect).map(s => s.value);
                            const newEmoji = availableEmojis.find(emoji => !otherValues.includes(emoji));
                            currentSelect.value = newEmoji;
                        });
                    }
                });
                
                playerDiv.appendChild(nameInput);
                playerDiv.appendChild(emojiSelect);
                playerDetailsContainer.appendChild(playerDiv);
            }
        }
        
        playerCountSelect.addEventListener('change', updatePlayerDetailsView);
        initialMoneySelect.addEventListener('change', () => initialMoneyCustom.classList.toggle('hidden', initialMoneySelect.value !== 'custom'));
        gameTimeSelect.addEventListener('change', () => gameTimeCustom.classList.toggle('hidden', gameTimeSelect.value !== 'custom'));

        // Start Game button event listener
        startGameBtn.addEventListener('click', () => {
            const players = [];
            const playerCount = parseInt(playerCountSelect.value);
            let money = initialMoneySelect.value === 'custom' ? parseInt(initialMoneyCustom.value) || 15000 : parseInt(initialMoneySelect.value);
            let time = gameTimeSelect.value === 'custom' ? parseInt(gameTimeCustom.value) : parseInt(gameTimeSelect.value);

            // Populate players array with names and emojis
            for (let i = 0; i < playerCount; i++) {
                players.push({
                    id: i, name: document.getElementById(`player-name-${i}`).value || `玩家 ${i + 1}`,
                    emoji: document.getElementById(`player-emoji-${i}`).value, money: money,
                    position: 0, inJail: false, jailTurns: 0, getOutOfJailCards: 0
                });
            }

            setupScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            initGame({
                players: players, currentPlayerIndex: 0,
                board: JSON.parse(JSON.stringify(boardDataWithOwners)), // Deep copy board data
                dice: [0, 0],
                gameEndTime: time > 0 ? Date.now() + time * 60 * 1000 : null,
                isGameOver: false
            });
        });

        // Initialize the game state and UI
        function initGame(loadedState) {
            gameState = loadedState;
            drawBoard();
            drawPlayerInfo();
            updatePlayerPawns();
            updateGameMessage();
            if (gameState.gameEndTime) {
                document.getElementById('end-game-btn')?.classList.add('hidden');
                startTimer();
            } else {
                const endGameBtn = document.getElementById('end-game-btn');
                if(endGameBtn) {
                  endGameBtn.classList.remove('hidden');
                  timerDisplay.textContent = '遊戲時間：無限制';
                }
            }
            if(gameState.isGameOver) endGame(true); else saveGameState();
        }

        // Draw the game board
        function drawBoard() {
            boardElement.innerHTML = `
                <div class="center-area bg-green-100 rounded-lg shadow-inner">
                    <h2 id="game-message" class="text-xl md:text-3xl font-bold text-center text-green-800 mb-4"></h2>
                    <div class="flex items-center justify-center space-x-4 mb-4">
                        <div id="dice1" class="w-12 h-12 md:w-16 md:h-16 bg-white rounded-lg shadow-md flex items-center justify-center text-3xl font-bold">?</div>
                        <div id="dice2" class="w-12 h-12 md:w-16 md:h-16 bg-white rounded-lg shadow-md flex items-center justify-center text-3xl font-bold">?</div>
                    </div>
                    <button id="roll-dice-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transition duration-300">擲骰子</button>
                    <div class="mt-4 space-y-2">
                         <button id="end-game-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 hidden">結束遊戲</button>
                         <button id="reset-game-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300">重置遊戲</button>
                    </div>
                </div>`;
            
            document.getElementById('roll-dice-btn').addEventListener('click', rollDice);
            document.getElementById('reset-game-btn').addEventListener('click', () => showConfirm("確定要重置遊戲嗎？所有進度將會遺失。", () => { localStorage.removeItem('monopoly_save_game'); location.reload(); }));
            document.getElementById('end-game-btn').addEventListener('click', () => showConfirm("確定要結束遊戲嗎？將會結算成績。", () => endGame()));

            gameState.board.forEach((space, i) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.className = `space space-${i}`;
                spaceDiv.id = `space-${i}`;
                if (space.type === 'property' || space.type === 'station' || space.type === 'utility') {
                     if(space.group) {
                        const colorBar = document.createElement('div');
                        colorBar.className = 'color-bar';
                        colorBar.style.backgroundColor = space.group;
                        spaceDiv.appendChild(colorBar);
                    }
                    spaceDiv.innerHTML += `<div class="name flex-grow flex items-center justify-center">${space.name}</div><div class="price">$${space.price}</div>`;
                } else if (['jail', 'parking', 'go', 'goToJail'].includes(space.type)) {
                    spaceDiv.classList.add('corner');
                    spaceDiv.innerHTML = `<div class="name">${space.name}</div>`;
                } else {
                    spaceDiv.innerHTML = `<div class="name flex items-center justify-center h-full">${space.name}</div>`;
                }
                const ownerIndicator = document.createElement('div');
                ownerIndicator.className = 'owner-indicator';
                ownerIndicator.id = `owner-${i}`;
                if (space.ownerId !== null) ownerIndicator.style.backgroundColor = playerColors[space.ownerId];
                spaceDiv.appendChild(ownerIndicator);
                boardElement.appendChild(spaceDiv);
            });

            // Create player pawns and append them directly to the board element
            gameState.players.forEach((player) => {
                const pawn = document.createElement('div');
                pawn.id = `pawn-${player.id}`;
                pawn.className = 'player-pawn';
                pawn.textContent = player.emoji; // Set the emoji as pawn content
                boardElement.appendChild(pawn); // Append to boardElement directly for z-index control
            });
        }
        
        // Draw player information in the sidebar
        function drawPlayerInfo() {
            playerInfoContainer.innerHTML = '';
            gameState.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.id = `player-info-${player.id}`;
                playerDiv.className = 'player-info p-3 rounded-lg border-2 mb-2 transition-all duration-300';
                playerDiv.style.borderColor = playerColors[player.id];
                if(player.id === gameState.currentPlayerIndex) playerDiv.classList.add('shadow-lg', 'bg-yellow-100');
                
                const playerProperties = gameState.board.map((s, i) => ({...s, index: i})).filter(s => s.ownerId === player.id);
                let propertiesHTML = playerProperties.map(p => {
                    const propColor = p.group || '#A9A9A9';
                    return `<span class="inline-block text-xs font-semibold mr-1 mb-1 px-1.5 py-0.5 rounded" style="background-color:${propColor}; color: ${isDark(propColor) ? 'white' : 'black'}">${p.name}</span>`;
                }).join('');
                if(propertiesHTML === '') propertiesHTML = '<span class="text-xs text-gray-500">無</span>';

                // Display player name with their chosen emoji
                playerDiv.innerHTML = `
                    <div class="flex justify-between items-center"><h4 class="text-lg font-bold" style="color:${playerColors[player.id]}">${player.name} ${player.emoji}</h4><span class="text-lg font-semibold">$${player.money}</span></div>
                    <div class="mt-2"><h5 class="text-sm font-bold mb-1">資產:</h5><div class="property-list">${propertiesHTML}</div></div>`;
                playerInfoContainer.appendChild(playerDiv);
            });
        }
        
        // Helper function to determine if a color is dark for text contrast
        function isDark(color) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16), g = parseInt(hex.substr(2, 2), 16), b = parseInt(hex.substr(4, 2), 16);
            return ((r * 299) + (g * 587) + (b * 114)) / 1000 < 155;
        }

        // Update player pawn positions on the board
        function updatePlayerPawns() {
            // Define relative offsets for pawns within a space, considering their doubled size
            const pawnRelativeOffsets = [
                { top: 10, left: 10 },    // Player 0: top-left corner
                { top: 10, right: 10 },   // Player 1: top-right corner
                { bottom: 10, left: 10 }, // Player 2: bottom-left corner
                { bottom: 10, right: 10 } // Player 3: bottom-right corner
            ];

            gameState.players.forEach((player) => {
                const pawn = document.getElementById(`pawn-${player.id}`);
                const spaceEl = document.getElementById(`space-${player.position}`);
                
                if (spaceEl && pawn) {
                    // Get the bounding rectangles of the space and the board for precise positioning
                    const spaceRect = spaceEl.getBoundingClientRect();
                    const boardRect = boardElement.getBoundingClientRect();

                    // Calculate the space's position relative to the board's top-left corner
                    const spaceLeftOnBoard = spaceRect.left - boardRect.left;
                    const spaceTopOnBoard = spaceRect.top - boardRect.top;

                    // Get the actual rendered size of the pawn (which might change with responsive CSS)
                    const pawnRect = pawn.getBoundingClientRect();
                    const pawnWidth = pawnRect.width;
                    const pawnHeight = pawnRect.height;

                    const offset = pawnRelativeOffsets[player.id % pawnRelativeOffsets.length];

                    let finalLeft, finalTop;

                    // Calculate final 'left' position based on relative offset
                    if (offset.left !== undefined) {
                        finalLeft = spaceLeftOnBoard + offset.left;
                    } else if (offset.right !== undefined) {
                        finalLeft = spaceLeftOnBoard + spaceRect.width - pawnWidth - offset.right;
                    }

                    // Calculate final 'top' position based on relative offset
                    if (offset.top !== undefined) {
                        finalTop = spaceTopOnBoard + offset.top;
                    } else if (offset.bottom !== undefined) {
                        finalTop = spaceTopOnBoard + spaceRect.height - pawnHeight - offset.bottom;
                    }
                    
                    // Apply calculated absolute positioning
                    pawn.style.position = 'absolute';
                    pawn.style.left = `${finalLeft}px`;
                    pawn.style.top = `${finalTop}px`;
                    // Clear other positioning properties to avoid conflicts
                    pawn.style.right = 'auto';
                    pawn.style.bottom = 'auto';
                }
            });
        }
        // Update the main game message
        function updateGameMessage(message) {
            const msgEl = document.getElementById('game-message');
            if(msgEl) msgEl.textContent = message || `輪到 ${gameState.players[gameState.currentPlayerIndex].name} ${gameState.players[gameState.currentPlayerIndex].emoji}`;
        }
        // Switch to the next player's turn
        function switchPlayer() {
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            // Skip bankrupt players only if there are still active players left
            const activePlayers = gameState.players.filter(p => p.money >= 0);
            if (activePlayers.length > 0) {
                while(gameState.players[gameState.currentPlayerIndex].money < 0) {
                     gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                }
            } else {
                // If all players are bankrupt, game ends. This is handled by checkBankruptcy.
                endGame();
                return;
            }
            
            updateGameMessage();
            drawPlayerInfo();
            document.getElementById('roll-dice-btn').disabled = false;
            
            if (gameState.players[gameState.currentPlayerIndex].inJail) handleJailTurn();
            saveGameState();
        }
        // Roll the dice and move the player
        function rollDice() {
            document.getElementById('roll-dice-btn').disabled = true;
            gameState.dice[0] = Math.floor(Math.random() * 6) + 1;
            gameState.dice[1] = Math.floor(Math.random() * 6) + 1;
            document.getElementById('dice1').textContent = gameState.dice[0];
            document.getElementById('dice2').textContent = gameState.dice[1];
            movePlayer(gameState.dice[0] + gameState.dice[1]);
        }
        // Move the player step by step
        async function movePlayer(steps) {
            const player = gameState.players[gameState.currentPlayerIndex];
            if(player.inJail) {
                if(gameState.dice[0] === gameState.dice[1]) {
                    player.inJail = false;
                    player.jailTurns = 0;
                    showMessage("擲出雙倍！你自由了！", () => movePlayer(steps));
                } else {
                    showMessage("在監獄中，擲骰失敗。", switchPlayer);
                }
                return;
            }
            const oldPosition = player.position;
            for(let i = 1; i <= steps; i++) {
                player.position = (oldPosition + i) % gameState.board.length;
                updatePlayerPawns();
                await new Promise(res => setTimeout(res, 100)); // Short delay for visual movement
            }
            // Check if player passed Go (start)
            if (player.position < oldPosition) {
                player.money += 2000;
                // Changed to auto-disappear message after 3 seconds, and only hide message modal
                showMessage('經過「起點」，領取薪水 $2000！', () => drawPlayerInfo(), 3000); 
            }
            setTimeout(() => handleSpaceAction(player.position), 200);
        }
        // Handle actions based on the space the player landed on
        function handleSpaceAction(position) {
            const space = gameState.board[position];
            const player = gameState.players[gameState.currentPlayerIndex];
            // Determine next turn action: if doubles, roll again; otherwise, switch player
            const nextTurn = () => {
                // Ensure the dice roll button is re-enabled or player is switched
                if (gameState.dice[0] !== gameState.dice[1]) {
                    switchPlayer();
                } else {
                    document.getElementById('roll-dice-btn').disabled = false;
                    updateGameMessage(`輪到 ${gameState.players[gameState.currentPlayerIndex].name} ${gameState.players[gameState.currentPlayerIndex].emoji}`);
                }
                saveGameState();
            };

            switch(space.type) {
                case 'property': case 'station': case 'utility':
                    if (space.ownerId === null) {
                        showBuyPropertyModal(space, position); // Unowned, offer to buy
                    } else if (space.ownerId !== player.id) {
                        payRent(space, position, nextTurn); // Owned by another player, pay rent
                    } else {
                        nextTurn(); // Owned by current player, do nothing
                    }
                    break;
                case 'chance': drawCard('chance'); break; // Draw a Chance card
                case 'destiny': drawCard('destiny'); break; // Draw a Destiny card
                case 'tax':
                    player.money -= space.amount;
                    showMessage(`繳交 ${space.name} $${space.amount}。`, () => { drawPlayerInfo(); nextTurn(); });
                    break;
                case 'goToJail': goToJail(); break; // Go to Jail space
                default: nextTurn(); break; // For 'Go', 'Jail', 'Parking'
            }
            checkBankruptcy(); // Check for bankruptcy after every action
        }
        // Calculate and pay rent
        function payRent(space, position, callback) {
             const owner = gameState.players.find(p => p.id === space.ownerId);
             if (!owner) { callback(); return; } // Should not happen if ownerId is set
             let rent = 0;
             if(space.type === 'property') rent = space.rent;
             else if (space.type === 'station') {
                 // Rent for stations increases based on how many stations the owner has
                 const count = gameState.board.filter(s => s.type === 'station' && s.ownerId === owner.id).length;
                 rent = space.rent * Math.pow(2, count - 1);
             } else if (space.type === 'utility') {
                 // Rent for utilities depends on dice roll and number of utilities owned
                 const count = gameState.board.filter(s => s.type === 'utility' && s.ownerId === owner.id).length;
                 rent = (gameState.dice[0] + gameState.dice[1]) * (count === 1 ? 40 : 100);
             }
             const player = gameState.players[gameState.currentPlayerIndex];
             player.money -= rent;
             owner.money += rent;
             showMessage(`降落在 ${owner.name} 的 ${space.name}，支付租金 $${rent}。`, () => { drawPlayerInfo(); checkBankruptcy(); callback(); });
        }
        // Send player to jail
        function goToJail() {
            const player = gameState.players[gameState.currentPlayerIndex];
            player.position = 10; // Jail space index
            player.inJail = true;
            player.jailTurns = 0; // Reset jail turns
            updatePlayerPawns();
            showMessage('你被送進監獄了！', switchPlayer);
        }
        // Handle player's turn while in jail
        function handleJailTurn() {
            const player = gameState.players[gameState.currentPlayerIndex];
            player.jailTurns++;
            if (player.getOutOfJailCards > 0) {
                // Use a Get Out of Jail Free card
                player.getOutOfJailCards--;
                player.inJail = false;
                player.jailTurns = 0;
                showMessage(`使用了「免費出獄卡」，輪到你行動。`);
                document.getElementById('roll-dice-btn').disabled = false; // Allow rolling again
            } else if (player.jailTurns > 3) {
                 // After 3 turns, pay bail
                 player.money -= 500;
                 player.inJail = false;
                 player.jailTurns = 0;
                 showMessage(`已在監獄待3回合，支付 $500 保釋金。`, () => { drawPlayerInfo(); document.getElementById('roll-dice-btn').disabled = false; });
            } else {
                 // Still in jail, skip turn
                 showMessage(`你在監獄中，還剩下 ${4 - player.jailTurns} 回合。`, switchPlayer);
            }
            saveGameState();
        }
        // Draw and process a Chance or Destiny card
        function drawCard(type) {
            const cardDeck = type === 'chance' ? chanceCards : destinyCards;
            const card = cardDeck[Math.floor(Math.random() * cardDeck.length)];
            showCardModal(type, card.text, () => handleCardAction(card));
        }
        // Perform action specified by the card
        function handleCardAction(card) {
            const player = gameState.players[gameState.currentPlayerIndex];
            // If not doubles and not going to jail, switch player; otherwise, allow rolling again
            const nextTurn = () => {
                if(gameState.dice[0] !== gameState.dice[1] || card.action === 'goToJail') {
                    switchPlayer();
                } else {
                    document.getElementById('roll-dice-btn').disabled = false;
                    updateGameMessage(`輪到 ${gameState.players[gameState.currentPlayerIndex].name} ${gameState.players[gameState.currentPlayerIndex].emoji}`);
                }
                saveGameState();
            };
            switch(card.action) {
                case 'money': player.money += card.amount; drawPlayerInfo(); nextTurn(); break;
                case 'move': player.position = card.position; if(card.position === 0) player.money += 2000; updatePlayerPawns(); handleSpaceAction(player.position); break;
                case 'moveRelative': movePlayer(card.amount); break;
                case 'goToJail': goToJail(); break;
                case 'getOutOfJail': player.getOutOfJailCards++; nextTurn(); break;
            }
            checkBankruptcy();
        }
        // Check if any player is bankrupt and end game if only one player remains
        function checkBankruptcy() {
            // Filter out bankrupt players
            const remainingPlayers = gameState.players.filter(p => p.money >= 0);

            // If only one or zero players remain, end the game.
            if(remainingPlayers.length <= 1 && !gameState.isGameOver) {
                // Show bankruptcy message for newly bankrupt players before ending
                gameState.players.forEach(player => {
                    if(player.money < 0 && !player.announcedBankruptcy) {
                        player.announcedBankruptcy = true; // Mark as announced to prevent repeated messages
                        showMessage(`${player.name} 破產了！`, () => {
                           gameState.board.forEach(space => { if (space.ownerId === player.id) space.ownerId = null; });
                           drawBoard(); // Redraw board to reflect ownership changes
                           // After message, recheck and potentially end game
                           if(gameState.players.filter(p => p.money >= 0).length <= 1) {
                               endGame();
                           }
                        });
                    }
                });
                // If the condition still holds (all bankrupt or only one left), end the game
                if (remainingPlayers.length <= 1) {
                    endGame();
                }
            } else {
                // For any players who just went bankrupt, but the game is not yet over (more than one active player left)
                gameState.players.forEach(player => {
                    if(player.money < 0 && !player.announcedBankruptcy) {
                        player.announcedBankruptcy = true;
                        showMessage(`${player.name} 破產了！`, () => {
                           gameState.board.forEach(space => { if (space.ownerId === player.id) space.ownerId = null; });
                           drawBoard();
                           // After message, if current player is bankrupt, switch to next valid player
                           if(gameState.players[gameState.currentPlayerIndex].money < 0) {
                                switchPlayer();
                           }
                        });
                    }
                });
            }
        }

        // Save game state to local storage
        function saveGameState() { if (!gameState.isGameOver) localStorage.setItem('monopoly_save_game', JSON.stringify(gameState)); }
        // Load game state from local storage or show setup screen
        function loadGame() {
            const savedGame = localStorage.getItem('monopoly_save_game');
            if (savedGame) {
                setupScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                initGame(JSON.parse(savedGame));
            } else {
                setupScreen.classList.remove('hidden');
                gameScreen.classList.add('hidden');
                updatePlayerDetailsView(); // Initialize player details for new game
            }
        }
        // Start the game timer
        function startTimer() {
            if (gameTimerInterval) clearInterval(gameTimerInterval);
            gameTimerInterval = setInterval(() => {
                if(gameState.isGameOver) { clearInterval(gameTimerInterval); return; }
                const remaining = gameState.gameEndTime - Date.now();
                if (remaining <= 0) {
                    timerDisplay.textContent = "時間到！"; clearInterval(gameTimerInterval); endGame();
                } else {
                    const minutes = Math.floor((remaining / 1000) / 60);
                    const seconds = Math.floor((remaining / 1000) % 60);
                    timerDisplay.textContent = `剩餘時間: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }
        // End the game and display results
        function endGame(isSilent = false) {
            if(gameState.isGameOver && !isSilent) return;
            gameState.isGameOver = true;
            document.getElementById('roll-dice-btn').disabled = true;
            if(gameTimerInterval) clearInterval(gameTimerInterval);
            
            // Calculate total assets for each player
            const playerAssets = gameState.players.map(player => {
                const propertyValue = gameState.board.filter(s => s.ownerId === player.id).reduce((sum, prop) => {
                    // For owned properties, calculate value at 90% of original price
                    if (prop.type === 'property' || prop.type === 'station' || prop.type === 'utility') {
                        return sum + (prop.price * 0.9); // 90% of original price
                    }
                    return sum;
                }, 0);
                return { ...player, totalAssets: Math.round(player.money + propertyValue) }; // Round to nearest integer
            }).sort((a, b) => b.totalAssets - a.totalAssets); // Sort by total assets descending

            // Filter out players who are effectively bankrupt and not ranked
            const rankedPlayers = playerAssets.filter(p => p.totalAssets >= 0);
            
            // Determine winner based on total assets, if any players have positive assets
            const winner = rankedPlayers.length > 0 ? rankedPlayers[0] : { name: '無人', emoji: '😭', totalAssets: 0 }; // Default if all are bankrupt

            document.getElementById('winner-text').textContent = `恭喜 ${winner.name} 獲勝！`;
            if (rankedPlayers.length > 0) {
                document.getElementById('winner-details').innerHTML = rankedPlayers.map((p, i) => `<div>#${i+1}: ${p.name} ${p.emoji} - 總資產 $${p.totalAssets}</div>`).join('');
            } else {
                 document.getElementById('winner-details').innerHTML = `<div>所有玩家皆已破產。</div>`;
            }
            
            modalContainer.classList.remove('hidden');
            winnerModal.classList.remove('hidden');
            localStorage.removeItem('monopoly_save_game'); // Clear saved game
        }
        // Event listener for playing again
        document.getElementById('play-again-btn').addEventListener('click', () => { location.reload(); });
        
        // Show a confirmation modal
        function showConfirm(text, onYes) {
            document.getElementById('confirm-text').textContent = text;
            document.getElementById('confirm-yes-btn').onclick = () => { closeModal(); onYes(); };
            document.getElementById('confirm-no-btn').onclick = closeModal;
            modalContainer.classList.remove('hidden');
            confirmModal.classList.remove('hidden');
        }
        // Show the buy property modal
        function showBuyPropertyModal(space, position) {
            document.getElementById('buy-property-name').textContent = space.name;
            document.getElementById('buy-property-price').textContent = `價格: $${space.price}`;
            const player = gameState.players[gameState.currentPlayerIndex];
            const buyBtn = document.getElementById('buy-btn');
            buyBtn.disabled = player.money < space.price; // Disable buy button if not enough money
            if(buyBtn.disabled) buyBtn.classList.add('opacity-50', 'cursor-not-allowed'); else buyBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            const nextTurn = () => {
                if (gameState.dice[0] !== gameState.dice[1]) {
                    switchPlayer();
                } else {
                    document.getElementById('roll-dice-btn').disabled = false;
                    updateGameMessage(`輪到 ${gameState.players[gameState.currentPlayerIndex].name} ${gameState.players[gameState.currentPlayerIndex].emoji}`);
                }
                saveGameState();
            };
            buyBtn.onclick = () => { player.money -= space.price; space.ownerId = player.id; document.getElementById(`owner-${position}`).style.backgroundColor = playerColors[player.id]; drawPlayerInfo(); closeModal(); nextTurn(); };
            document.getElementById('skip-buy-btn').onclick = () => { closeModal(); nextTurn(); };
            modalContainer.classList.remove('hidden'); buyPropertyModal.classList.remove('hidden');
        }
        // Show a card modal (Chance or Destiny)
        function showCardModal(type, text, callback) {
            const cardTitle = document.getElementById('card-title');
            cardTitle.textContent = type === 'chance' ? '機會' : '命運';
            cardTitle.className = `text-2xl font-bold mb-2 ${type === 'chance' ? 'text-blue-500' : 'text-orange-500'}`;
            document.getElementById('card-text').textContent = text;
            document.getElementById('card-ok-btn').onclick = () => { closeModal(); callback(); };
            modalContainer.classList.remove('hidden'); cardModal.classList.remove('hidden');
        }

        // Helper function to check if any other modal (besides messageModal) is currently visible
        function anyOtherModalVisible() {
            return ![buyPropertyModal, cardModal, winnerModal, confirmModal].every(m => m.classList.contains('hidden'));
        }

        // Show a general message modal, with optional auto-close
        function showMessage(text, callback, autoCloseDelay = 0) {
            document.getElementById('message-text').textContent = text;
            const messageOkBtn = document.getElementById('message-ok-btn');
            
            // Define the action to take when the message modal closes
            const closeMessageAndContinue = () => {
                messageModal.classList.add('hidden'); // Hide only the message modal
                if (!anyOtherModalVisible()) { // Only hide the modal container if no other modals are active
                    modalContainer.classList.add('hidden');
                }
                if (callback) callback();
            };

            messageOkBtn.onclick = closeMessageAndContinue;
            messageOkBtn.classList.remove('hidden'); // Ensure button is visible by default

            if (autoCloseDelay > 0) {
                messageOkBtn.classList.add('hidden'); // Hide the button for auto-close messages
                setTimeout(closeMessageAndContinue, autoCloseDelay);
            } else {
                messageOkBtn.classList.remove('hidden'); // Show button if no auto-close
            }

            modalContainer.classList.remove('hidden'); // Ensure container is visible
            messageModal.classList.remove('hidden'); // Ensure message modal is visible
        }
        
        // Close all modals (used for explicit closure, e.g., from an "OK" button)
        function closeModal() {
            modalContainer.classList.add('hidden');
            [buyPropertyModal, cardModal, messageModal, winnerModal, confirmModal].forEach(m => m.classList.add('hidden'));
        }
        
        window.onload = loadGame;
    </script>
</body>
</html>
